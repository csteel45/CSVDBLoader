package com.fortmoon.utils;import java.util.*;import java.io.*;import javax.swing.*;import javax.swing.table.*;/** * PropertyModel provides model interface for Properties object *  * @author Chris Steel - Sun Java Center * @version $Revision: 1.8 $ * @date $Date: 2000/11/16 19:32:58 $ */public class PropertyModel extends AbstractTableModel {	private static final long serialVersionUID = 1L;	private Vector<String> columnNames;	private Properties properties = new Properties();	private TreeMap<String, String> map = new TreeMap(properties);	private String password = null;	private final static String PasswordPropertyKey = "CA.NCMEC.ImageServer.Password";	private static final String MagicKey = "CA.NCMEC.MagicKey";	//private boolean reLoaded = false;	private char[] propertyPassword;	public PropertyModel() {		columnNames = new Vector<String>();		columnNames.addElement("Name");		columnNames.addElement("Value");	}	public void load(InputStream inputStream) {		try {			if (propertyPassword != null) {				System.out.println("PropertyModel.load loading from encrypted input stream.");				properties.load(inputStream);			}			else				properties.load(inputStream);			map = new TreeMap(properties);		}		catch (Exception e) {			System.out.println("Exception loading from input stream: " + e);			e.printStackTrace();		}		//reLoaded = true;		if (map.containsKey(PasswordPropertyKey)) {			password = (String) map.get(PasswordPropertyKey);			cloakPassword();			System.out.println("Loaded password: " + password);		}		fireTableDataChanged();	}	public void save(OutputStream outputStream) {		System.out.println("PropertyModel.save called.");		try {			properties.clear();			properties.putAll(map);			if (getProperty(MagicKey) == null) {				properties.put(MagicKey, "MagicValue");			}			if (map.containsKey(PasswordPropertyKey)) {				properties.put(PasswordPropertyKey, password);			}			properties.store(outputStream, null);		}		catch (Exception e) {			System.out.println("Exception storing to output stream: " + e);			e.printStackTrace();		}		cloakPassword();		fireTableDataChanged();	}	public void cloakPassword() {		String passField = getValue(PasswordPropertyKey);		String shadow = new String();		for (int i = 0; i < password.length(); i++)			// This is not optimal but so what.			shadow += "*";		// System.out.println("Shadowing = " + shadow);		map.put(PasswordPropertyKey, shadow);		fireTableDataChanged();	}	public String getColumnName(int col) {		return (String) columnNames.elementAt(col);	}	public int getColumnCount() {		return (columnNames.size());	}	public int getRowCount() {		return (map.size());	}	public boolean isCellEditable(int row, int column) {		return false;	}	public String getValue(String key) {		return (String) map.get(key);	}	public Object getValueAt(int row, int col) {		// System.out.println("getValueAt called for row: " + row);		if (col == 0)			return map.keySet().toArray()[row];		else			return (map.values().toArray()[row]);	}	public void setValueAt(Object value, int row, int column) {		System.out.println("setValueAt called for row: " + row);		if (column == 0) {			String val = (String) getValueAt(row, 1);			map.put((String)value, val);		}		else {			String key = (String) getValueAt(row, 0);			map.put(key, (String)value);			if (key.equals(PasswordPropertyKey)) {				password = (String) value;				cloakPassword();			}		}		fireTableRowsUpdated(row, row);	}	public Object getRow(int row) {		// System.out.println("getRow called for: " + row);		return (map.keySet().toArray()[row]);	}	public void changeRowAt(String name, String value, int row) {		System.out.println("changeRowAt called for row: " + row);		if (map.size() > row) {			map.put(name, value);			if (name.equals(PasswordPropertyKey)) {				password = value;				cloakPassword();			}			fireTableDataChanged();		}		else {			addRow(name, value);		}	}	public void addRow(String name, String value) {		System.out.println("addRow for name: " + name);		map.put(name, value);		if (name.equals(PasswordPropertyKey)) {			// if(password != null) {			// PasswordDialog p = new PasswordDialog();			// p.show();			// if(p.getValue() == 0) {			// password = new String(p.getSecondNewPassword());			// }			// p.dispose();			// p = null;			// }			password = value;			cloakPassword();		}		fireTableDataChanged();	}	public boolean isRow(String key) {		if (map.containsKey(key)) {			return (true);		}		return (false);	}	public void removeRow(String key) {		// System.out.println("remove row: " + key);		map.remove(key);		fireTableDataChanged();	}	public void removeRowAt(int index) {		// System.out.println("removeRowAt: " + index);		String key = (String) getValueAt(index, 0);		map.remove(key);		fireTableDataChanged();	}	public void removeAllRows() {		// System.out.println("removeAllRows called");		properties.clear();		map.clear();		fireTableDataChanged();	}	public String getProperty(String key) {		return this.properties.getProperty(key);	}	public void setPropertyPassword(char[] propPass) {		propertyPassword = propPass;	}/*	public Object clone() {		try {			super.clone();		}		catch (CloneNotSupportedException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}		PropertyModel copyObj = new PropertyModel();		copyObj.properties = (Properties) properties.clone();		copyObj.map = (TreeMap) map.clone();		return (copyObj);	}*/}
